<!doctype html>
<html>

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" integrity="sha384-B0vP5xmATw1+K9KRQjQERJvTumQW0nPEzvF6L/Z6nronJ3oUOFUFpCjEUQouq2+l" crossorigin="anonymous">

    <link rel="stylesheet" href="./intermediate_part1.css">

    <title>Document</title>
</head>

<body>
    <div class="black-bg">
        <div class="white-bg">
            <p>로그인 하세요</p>
            <form id="login-form">
                <div class="form-group">
                    <input type="text" class="form-control" id="login_email" placeholder="Email">
                    <p id="email-alert" style="color: red; display: none;">이메일을 입력해주세요</p>
                </div>
                <div>
                    <input type="password" class="form-control" id="login_pw" placeholder="Password">
                    <p id="pw-alert" style="color: red; display: none;">비밀번호를 입력해주세요</p>
                </div>
                <div class="mt-3" style="display:inline-block;">
                    <button type="submit" class="btn btn-primary btn-sm">Login</button>&nbsp;
                    <button type="button" class="btn btn-danger btn-sm" id="login-close">Close</button>
                </div>
            </form>
        </div>
    </div>

    <div class="nav-menu">
        <h4>Shirts Studio</h4>
        <a id="nav-sub-btn">Products</a>
    </div>

    <ul class="list-group nav-sub">
        <!--서브메뉴는 부트스트랩 list-group이용-->
        <li class="list-group-item">Outer</li>
        <li class="list-group-item">Innerwear</li>
        <li class="list-group-item">Shirts</li>
    </ul>

    <div class="left-menu">
        <p>Menu-title</p>
    </div>

    <div class="jumbotron main-background">
        <h1 class="display-4">Shirts Studio</h1>
        <p class="lead">This is a simple hero unit, a simple jumbotron-style component for calling extra attention to featured content or information.</p>
        <hr class="my-4">
        <a class="btn btn-primary btn-lg" id="btn-login" href="#" role="button">Log-in</a>
        <a class="btn btn-danger btn-lg ml-2" id="show-menu" href="#" role="button">Show Menu</a>
    </div>

    <div style="margin-top: 20px">
        <form>
            <input type="text" id="homework-if">
            <button id="homework-click">369확인</button>
        </form>
    </div>

    <!--<input id="test-input"/>-->


    <!--jQuery CDN-->
    <script src="https://code.jquery.com/jquery-3.5.1.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
    <!--slim버전이라 제낌 <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>-->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-Piv4xVNRyMGpqkS2by6br4gNJ7DXjqk09RmUpJ8jgGtD7zP9yug3goQfGII0yAns" crossorigin="anonymous"></script>

    <script>
        if (1 === '1') {
            console.log("안녕1"); //console.log() >> 콘솔에 로그 띄우는 함수
        } else if (1 == '1') {
            console.log("안녕2");
        } else {
            console.log("안녕3");
        }

        //        $("#login-form").on('submit', function(e) {
        //            if ($("#login_email").val() == '') { // 실제로 console.log()로 빈 input을 출력해보면 ""로 나온다
        //                //alert("이메일을 입력하세요");
        //                $("#email-alert").show();
        //                e.preventDefault();
        //            }
        //            if ($("#login_pw").val() == '') {
        //                //alert("비밀번호를 입력하세요");
        //                $("#pw-alert").show();
        //                e.preventDefault();
        //            }
        //        }); // 정규식 대체

        //HTML5부터는 input type에 email도 생겼지만

        const emailRex = /^[0-9a-zA-Z]([-_.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_.]?[0-9a-zA-Z])*.[a-zA-Z]{2,3}$/i;
        const emailRex2 = /^(([^<>()\[\]\.,;:\s@\"]+(\.[^<>()\[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()\.,;\s@\"]+\.{0,1})+([^<>()\.,;:\s@\"]{2,}|[\d\.]+))$/; // 특수문자만 거르는 케이스 요즘에는 이쪽을 더 선호

        /*
        //i 정규식 패턴이 대소문자 구분을 사용하지 않음
        ^는 문자열의 시작을 표현
        *는 0회 이상 그 이상의 문자가 대응(+은 1회이상)
        $는 입력의 끝부분과 대응 문자열 종료가 무엇으로 되는지
        {n,m} 앞 문자가 최소 0개 최대 1개 {n} n번반복 {n,} n번이상 반복
        ? {0,1}과 같은 의미 존재할수도 안할수도
        ()그룹표현
        [^a-z] 등 의 ^는 not을 의미

        */

        const pwRex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[$@$!%*?&])[A-Za-z\d$@$!%*?&]{8,}/;

        //이런식으로 그룹화한 조건들이 포함되어 있는지를 pw에서 사용
        //?= 전방탐색 (후방탐색은 ?<=\$) 작성한 패턴이 일치하는 영역이 존재해도 그 값이 소비되지 않음(일치하는 영역을 반환하지 않음)

        /*  전방탐색 질문 답변
            정규식은 문자를 소비하는 형식으로 하나하나 찾아나감
            /a(?=b) 가 있다면 a는 확인후 그 문자를 소비함
            이후 b의 경우 찾은 문자를 소비하지 말고 그냥 있는지만 확인함
        */

        // http:// 에서 .+(?=:)라고 하면 :를 찾은건 체크하고 이제 다시 전방부터 탐색하되 :은 소비되지 않음
        //.*는 모든 문자열 따라서 (?=.*[a-z])는 소문자체크

        $("#login-form").on('submit', function(e) {
            let email = $("#login_email").val();
            let pw = $("#login_pw").val();

            console.log(email);
            console.log(emailRex);

            if (email == "") {
                alert("이메일이 공백입니다.");
                e.preventDefault();

            } else if (!emailRex.test(email)) {
                $("#email-alert").show();
                e.preventDefault();
            } else {
                $("#email-alert").hide();
            }

            if (!/[A-Z]{1,}/.test(pw)) {
                $("#pw-alert").show();
                e.preventDefault();
            } else {
                $("#pw-alert").hide();
            }


        });



        $('#btn-login').click(function() {
            //$('.black-bg').show();
            //$('.black-bg').fadeIn();
            //$('.black-bg').slideDown();
            //$('.black-bg').show();
            //$('.black-bg').css('margin-top', '0px');
            //$(".black-bg").animate({marginTop:"0px"}, 1000);
            //$(".black-bg").css('transform','translateY(0px)');
            $(".black-bg").addClass("black-trans"); // addClass(), removeClass() 클래스명에는 셀렉터 안붙인다
        });

        $('#login-close').click(function() {
            //$('.black-bg').fadeOut();
            //$(".black-bg").animate({marginTop:"-1200px"}, 1000).hide();
            //$('black-bg').css('margin-top', '-1200px');
            //$('.black-bg').hide();
            //$(".black-bg").css('transform','translateY(-1200px)');
            $(".black-bg").removeClass("black-trans");
            $("#email-alert").hide();
            $("#pw-alert").hide();
        });

        $('#nav-sub-btn').click(function() {
            $('.nav-sub').slideToggle();
        });

        $("#login_email").on("change", function() {
            console.log("change됨");
        });
        $("#login_email").on("input", function() {
            console.log("input중")
        });

        let menuOn = true;

        $("#show-menu").click(() => {
            if (this.menuOn) {
                $(".left-menu").animate({
                    marginLeft: "0px"
                }, 1000);
                this.menuOn = false;
            } else {
                $(".left-menu").animate({
                    marginLeft: "-150px"
                }, 1000);
                this.menuOn = true;
            }
        });
    </script>

    <script>
        // 과제파트

        let 예금액 = 60000;
        let 미래예금액 = 0;

        if (예금액 >= 50000) {
            미래예금액 = (예금액 * 1.2) * 1.2;
        } else {
            미래예금액 = (예금액 * 1.15) * 1.15;
        }

        console.log("미래예금액 : " + 미래예금액);


        let 첫커피 = 360;
        let 마신커피 = 0;

        마신커피 = 첫커피 + (첫커피 * 2 / 3) + (첫커피 * 4 / 9);

        console.log("마신커피 : " + 마신커피);
    </script>
</body></html>


<!-- 5/18 : 변수 var / let / const (es6 신문법)

     변수 : var 변수명 = 대입할 데이터 값; >> 자료 저장 or 참조 주소

     변수에 넣는 데이터는 참조값도 되므로 $("#login_email") 같은 것도 가능
     >> 특히 이런 셀렉터를 변수에 담는 습관은 매우 좋다
     >> 셀렉터를 쓸 때마다 HTML을 탐색하기에 참조값을 성능상 변수에 저장하여 사용하면 성능이 매우 향상

     변수 활용 이유 : 가장 큰 이유는 코드의 간략화

     변수 활용 개념 : 선언 / 할당 / 범위

     > 선언 : var 변수명; (해당 변수명을 말그대로 선언 / Typescript Java같은 컴파일언어처럼 데이터 타입이 크게 없으므로...)

     > 할당 : 변수명 = 대입할 값; (선언된 변수에 값을 넣음)

     var 나이 = 18; >> 선언과 할당을 동시에 쌉가능

     > 범위 : 선언한 변수가 유효한 영역(지역 : 일반적으로 전역변수 아니면 지역(함수 등 안)으로 생각 / 상위요소의 변수는 하위요소에서 통함)



     es6 신문법 : let / const 추가

     >> let : 재선언이 불가능한 변수 (읭?할수가 있는데 js에서는 같은 이름으로 선언이 가능함....ㄷㄷㄷ let을 가능한 브라우저면 쓰자)

     >> const : 재선언 + 재할당(값 바꿔 대입) 불가 (final) / 근데 프론트환경에서는 그닥 쓸일이 많이 없음

     >> 범위 문제 : var가 function이면 나머지는 {} ... 먼가 범위가 좀 더 작음 / 변수 범위가 작아 겹치는 확률이 적음


     변수 Hoisting : 위 범위문제에 대해 function 범위와 {} 범위 무엇차이인지 좀 더 알 수 있음

     > 일반적인 프로그래밍의 지역변수는 당연히 선언되 {}에서만 유효 (let과 const도 그러하다)
     > 하지만 JS의 var는 아니다 (?????)

     > if(true) { var name = "chin"; } console.log(name); 하면 콘솔에 이름이 뜸(???!!!)
     > for(var i = 0; i < 100; i++) { //do something } console.log(i); 심지어 얘도 뜬다(???!!!)

     >> 이런 현상이 발생하는게 var 변수가 호이스팅 되기 때문
     >> Hoisting : var를 통해 정의된 변수의 선언문을 유효범위의 최상단으로 끌어올리는 행위 (선언과 할당의 분리)

     >> var는 위에서 유효범위가 function이라고 했는데,
        이는 let과 const가 선언된 {}에 유효하다면, var는 선언된 {}가 아니라 선언된 곳의 function영역이란 것

        즉 간단히 위에서 했던
        function ex1() {
            if(true) { var name = "chin"; }
            console.log(name);
        }
        이런 코드를 개발자가 짰다면

        실제 JS는 호이스팅에 의해 var의 유효범위 최상단으로 선언과 할당을 분리시켜 올려주기 때문에
        function ex1() {
            var name;
            if(true) { name = "chin"; }
            console.log(name);
        }
        으로 처리되게 된다.

        global scope도 하나의 function scope처럼 이뤄지기 때문에 마찬가지다


        cf) 함수 선언의 호이스팅
        ex1();
        ex2();

        var ex1 = function() {}
        function ex2() {}

        의 경우 함수 호이스팅이 발생하기에 문제없이 실행된다.

        하지만
        var ex1;

        ex1();

        ex1 = function() {}

        의 경우 문제가 터지는데 호이스팅은 '선언과 할당을 분리'해 '선언을 유효범위 상단'으로 올려주는것
        따라서 할당이 호출 뒤에 일어나므로 저리됨

    5/21 : JS 사칙연산
    별거 없음 Java때처럼 +, -, /, *사용하면 됨

    단지 + 는 문자열이 하나라도 끼면 문자열을 합치는 연산을 자동으로 해줌 (숫자파트를 문자화 시키지 않아도)

    더 주의할 점은 나머지 연산자의 경우 문자열이 꼈을때 문자열 내부가 숫자면 알아서 숫자연산으로 해줌

-->

<!-- 5/21 : jQuery Animate => 특정 css요소 변경을 지정시간동안 천천히 시킬 수 있음

     기존 CSS 애니메이션 적용은 비교적 제약사항이 존재
     따라서 JS나 jQuery로 보강하면 매우 편리하게 애니메이션 적용이 가능함

     키입력, 클릭했을때나 스크롤 했을때 이럴경우 애니메이션 적용 좋음 >> 구현 영역이 넓어짐 (CSS는 마우스를 올렸을때 경우등)

     오른쪽으로 이동시킬 경우
     $("").animate({ marginLeft : '100px'}, 1000);

     >> 첫번째 파라미터는 CSS속성을 Object 타입(js Object타입은 {key:value})으로 지정
        이때 JS에서 '-'는 연산자이므로 CamelCase로 바꾼다

     >> 2번째 파라미터의 시간은 밀리초 기준

     애니메이션은 UI만들고 감추고 보여주는 단계에 시간을 늘리는것일뿐


     애니메이션2

     login slide() 직접 처리 : margin-top을 -1200로 하고 animate를 줌
     +
     show(), hide() 등 순서적용
     jQuery에서 함수를 순서대로 적용하려면 콜백함수로 연결이 된다 (시간문제로 순서적용이 안될수 있기에 Event Queue, Stack, Evnet Loop 참조)
     animate(~).hide()가 가능
     +
     animate를 추가로 작성하고 싶으면 animate()의 세번째 파라미터로 콜백함수를 추가해준다
     animate(~,1000,function(){
         animate(~)
     })


     애니메이션 작성 추천
     1. basic 애니메이션 작성 순서 : 시작화면+최종화면 만들기 >> JS로 트리거하기 >> 스무스한 동작은 animate()적용

     2. 근데 요즘엔 animate 잘 안씀 >> CSS 속성을 사용한다 (transaction 속성 이용) | 물론 트리거는 JS 계속 씀

     CSS 속성 선호 이유
     1) transition은 JS와 독립적으로 동작 : JS로 애니메이션까지 주면 성능상의 부담이 감
     >> 특히 SPA만들때는 하면 안됨 (transition쓰거나 velocity.js같은 애니메이션 전용 라이브러리 사용)

     2) transition이 적용 및 조정에 쉬움

     3. 애니메이션을 margin, width, position, left, right, height 등에 주면 안된다. >> transform 속성을 사용
     transform
     >> translate() 위치이동; rotate() 회전; scale() 사이즈변경; 등

     레이아웃 변경 속성(margin width 등)을 쓰지 않은 이유 : 레이아웃 속성등은 변경시 랜더링 시간이 오래걸림
     이에 비해 transform, opacity같은 속성들은 페이지 레이아웃과 관련이 없기에 빠르게 처리가 된다 (브라우저 css 랜더링 단계 공부)

     4. 애니메이션용 클래스 제작 + addClass() + removeClass()를 활용하여 클래스 단위로 애니메이션을 만든다 (애니메이션을 최대한 Css에 맡김)
     >> 코드 유지관리, 재사용성과 간결성에 좋아진다.
-->

<!--5/27 : 정규식 >> 문자형식 체크할 때 쓰는 문법

    ex 문자열에 'abc'가 들어갔는가? /abc/ '동일한가가 아니라 들어가 있는가임'
       검사할 문자열 'abcde' >> /abc/.test('abcde') >> boolean형으로 반환

    간단한 JS정규식 핵심 문법 몇가지 (대부분 필요할 때마다 찾아봄 email regular expression 등)
    일단 //안에 넣음
    [] : 찾을 문자의 범위 /[A-z]/ 모든 A~z까지의 문자 포함하나
    \S (혹은 원화) : 특수문자 포함 모든 문자 (정확히는 공백이 아님을 표현 \s는 공백문자) >> 응용 모든 문자다음에 @ >> /\S@/
    \w word를 의미 알파벳, 숫자, _ 중 하나
    \W non word 위의 역
    \d digit 숫자
    \D non digit
    \b word boundary 문자와 공백 사이 문자

    + : 뒤에도 위 조건이 맞는지 확인 >> \S+@ 하면 됨

    간단한 이메일 정규식 /\S+@\S+.\S/ 에서 '.'은 이스케이프 문자(\)랑 같이 써줘야함 /\S+@\S+\.\S/ (물론 실제로 이거 쓰면 안됨)


-->
