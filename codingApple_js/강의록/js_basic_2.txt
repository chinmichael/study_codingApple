1. JS의 변수 설정

Javascript에서도 변수를 사용해 자주 쓰는 값이나 셀렉터를 저장하는건 좋은 습관이다.
Javascript에서도 Java와 마찬가지로 데이터 저장이나 참조주소 저장이 가능하기에 셀렉터 등을 저장하는 것도 가능

사용하는 이유는 
1. 재랜더링시마다 메모리 재할당을 줄일 수 있고,
2. 해당 셀렉터를 사용할 때마다 HTML에서 새로 읽어오는 것을 줄일 수 있고 ex) $변수명 = $('셀렉터').html();
3. 코드의 간략화가 가능해진다.

변수 활용 개념에는 : 선언 / 할당 / 범위가 있음

선언 : 변수명을 선언 let item; (Java나 TypeScript처럼 데이터 타입이 크게 없으므로 거의 변수명만 선언된다)

할당 : 선언된 변수명에 데이터 혹은 주소값을 대입시킴 item = '1';

let item = '1';은 선언과 할당을 동시에 한 것

범위 : 선언한 변수가 유효한 영역

>> 일반적으로 const와 let은 Java의 지역변수 개념이 통하는데 var는 아니다... 자세한건 밑에서


2. var / let / const

var : 재선언 가능 / 재할당 가능 / 함수범위

let : 재선언 불가 / 재할당 가능 / 지역{}변수범위

const : 재선언 불가 / 재할당 불가 / 지역{}변수범위

let과 const는 Java를 사용하는 입장에서 일반적인 변수와 final 상수를 생각하면 편한다

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

문제는 기존의 var의 재선언 가능과 함수범위의 문제

재선언은... var는 특이하게 같은 변수명으로 새로운 변수가 선언이 된다... 이게 왜 되면 상상대로 골치아픈 상황이 터지기 마련이다

var의 함수범위는 일반적인 프로그램의 지역변수 개념으로 생각하면 매우 ????이 되는데,
Hoisting 개념을 더하면 조금 이해가 된다.

let과 const는 당연히 선언된 {} 안에서만 유효하지만 (기존 프로그래밍 언어의 변수들도 그러하다)
var는 {} 밖에서도 유효할 때가 있다

예를 들어 for(var i=0; i < 100; i++){//do something} console.log(i);을 찍으면 선언된 for문 밖인데도 콘솔에 i값이 찍힌다

이는 JS Hoisting (정의된 변수의 선언문을 유효범위의 최상단으로 끌어올리는 행위)과 같이 보면 좀 이해가 되는데
(애초에 저 Hositing도 Java에서 당근 변수가 선언된 뒤에 사용이 가능한 개념에서 보면 ???? 지만)
(그래도 선언만 분리되어 호이스팅 되지 할당은 자리 유지가 된다)

let과 const는 Hositing된다면

if(~) {
    ...
    let ex = 1;
} 에서

if(~) {
    let ex;
    ...
    ex = 1;
} 로 끌어올려지지만

var는 함수 범위이기 때문에

function ex1() {
    ...
    if(~) {
        ...
        var ex = 1;
    }
}를 하면 if문 내부가 아니라

function ex1() {
    var ex;
    ...
    if() {
        ...
        ex = 1;
    }
} 으로 끌어 올려진다. 당연히 function 내에 var가 아니라면 전역(global)객체의 최상단 변수로 호이스팅된다...


=======================================================================================
=======================================================================================

1. Animation

JS를 이용하면 기존 CSS만 이용하다너 경우에 비해 제약사항을 크게 줄일 수 있다
(키입력, 스크롤 등의 이벤트와 쉽게 엮을 수 있다)

jQuery의 animate() 함수보다는
CSS 속성(transition 등)을 활용하여 변경사항을 만드는 클래스를
JS를 이용해 트리거 이벤트 때 붙여주는 것이 좋다 (jQuery를 이용한다면 addClass React, Vue를 이용한다면 데이터바인딩)


2. 기본적인 애니메이션 작성 순서

시작화면(transition 적용) + 최종화면 만들기 >> JS로 트리거 잡기 >> 트리거에 최종화면을 위한 클래스 붙이기

JS로 애니메이션까지 주면 SPA에 문제가 생기거나 성능상에 부담이 가기에 transition이 좋다

Layout이나 Paint CSS 요소보다는 Composite 요소(transform, opacity)를 변경하는 방식으로 애니메이션을 준다
모달창 안보이는거요? 차피 리액트 등을 쓸텐데 그건 아예 해당 HTML요소를 조건state로 없애버리면 됨

만약 트리거 적용이 어려운 애니메이션은 그냥 @keyframes을 이용한다.


=======================================================================================
=======================================================================================

JS 기본 연산자 주의사항

기본연산자 자체는 Java의 것과 거의 유사하게 작용
대신 몇몇 JS만의 독특한 주의사항이 몇 가지 존재한다.

1. 느슨한 비교 ==와 엄격한 비교 ===

데이터 타입이 거의 없는 JS의 특성상 ==을 사용하면 1 == '1' 알아서 타입변환이 들어가서 내용물을 비교해버린다
타입자체도 함께 확인하기 위해서는 ===을 사용


2. + '문자열'은 Java처럼 알아서 문자열로 전환해 붙이기를 하지만 나머지 연산자는 문자 내부가 숫자면 알아서 타입전환해서 계산한다...


=======================================================================================
=======================================================================================

1. 정규식 >> 문자열의 형식을 체크할 때 사용

Java나 JS 정규식을 사용할 때마다 참고해서 공부해나가는게 좋음

JS에서 문자열 테스트는 /정규식/.test(문자열) 으로 bool 반환을 받아 판단한다.

ex)
const pwRex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[$@$!%*?&])[A-Za-z\d$@$!%*?&]{8,}/;
if(!pwRex.test(pw)) {}


기본적인 정규식 표현

[] : 찾을 문자의 범위, 이 안에 요소 하나라도 대응되는지 /[A-z]/ 아스키코드 기준으로 소문자가 뒤에 있으므로
[^] : 해당 요소 제외하고 매칭 [^abc] > a,b,c 모두 제외

\s : 공백문자 space
\S : 특수문자를 포함하는 모든 문자 = 정확히는 공백이 아님을 표현 (모든 문자 다음에 @가 있는지 /\S@/)

\w : 알파벳, 숫자, _ 중 하나(word)
\W : non-word 위의 역

\d : digit 숫자
\D : non-digit

\b : word boundary 문자와 공백 사이 문자

+ : 뒤 조건이 맞는지 확인
\ : 이스케이프, 해당 문자가 정규식 구분이 아닌 그냥 문자임을 지정 \+ 을 하면 위 정규식 +가 아닌 기호 +임

/\S+@\S+@\S+\.\S/ 로 간단한 메일 확인 가능

const emailRex = /^[0-9a-zA-Z]([-_.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_.]?[0-9a-zA-Z])*.[a-zA-Z]{2,3}$/i;
const emailRex2 = /^(([^<>()\[\]\.,;:\s@\"]+(\.[^<>()\[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()\.,;\s@\"]+\.{0,1})+([^<>()\.,;:\s@\"]{2,}|[\d\.]+))$/; // 특수문자만 거르는 케이스 요즘에는 이쪽을 더 선호

/정규식/i : 정규식 패턴이 대소문자 구분을 하지 않게 함
^   : 문자열의 시작을 표현
$   : 문자열의 끝 표현

()  : 그룹을 표현

*   : 앞 문자가 0회 이상 대응(+는 1회이상 대응)
.*  : 모든 문자열

{n,m}, {n} : 앞 문자가 최소 n개 이상 m개 이하 대응
?   : = {0,1} 앞 문자가 있을수도 없을수도 있음

const pwRex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[$@$!%*?&])[A-Za-z\d$@$!%*?&]{8,}/;

?=      : 전방탐색 : 작성한 패턴이 일치하는 영역이 존재해도 그 값이 소비되지 않음
?<=\$   : 후방탐색

>>  정규식은 문자를 소비하는 방식으로 하나하나 탐색이 이뤄진다
    /a(?=b)/ 가 있다면 a는 확인 후 그 문자를 소비하고 b는 그냥 있는지만 확인한다.




=======================================================================================
=======================================================================================

1. Carousel UI (회전목마 > 슬라이드 UI)

우선 UI 애니메이션은
1. 시작화면 (transition)
2. 최종화면
3. JS로 Trigger
4. 애니메이션 transform, opacity 등 클래스 붙이기

트리거가 딱히 없으면 @keyframes

Carousel 애니메이션 핵심

width 100%혹은 100vw(viewport = 브라우저화면)의 slide되는 div를 n개 만들고
이들을 감싸는 width 100 * n %(혹은 vw)의 container div를 만들어

container에 transition: transform 1s; 을 준뒤

container div에 추가로 transform: translateX(-n * 100vw); 가 적용된 class를 트리거에 따라 붙여준다.


=======================================================================================
=======================================================================================


=======================================================================================
=======================================================================================

