1. ES6에서 업그레이드 된 function의 default 파라미터

function sumFunc(a, b) {
    console.log(a + b);
}

sumFunc(1);

JS 기본 function 이상한 특징 1.

함수 실행시 파라미터 개수가 맞지 않더라도 에러가 발생하지 않음 >> JAVA같은거에선 상상도 못하지 ㄷㄷ

>> 대신 es6부터 default 파라미터를 넣을 수 있다. (굳이 if문을 쓰지 않아도 직관적 사용 가능)
>> defualt 파라미터로는 연산이나 파라미터 변수, return값이 있는 함수도 가능하다.

function sumFunc(a, b = 10) {
    console.log(a + b);
}

sumFunc(1); 을 하면 콘솔에 11이 나온다 (b에 파라미터가 안들어와 자동으로 10이 채워짐) >> React Reducer에서도 쓰지
참고로 default값이 있으므로 sumFunc을 하면 NaN(Not a Number)으로 숫자끼리 연산이 안 이뤄진 결과가 나온다.

function sumFunc(a, b = 2 * 5) {
    console.log(a + b);
}
추가적으로 위와 같은 연산도 된다.

function sumFunc(a, b = 2 * a) { >> 당연 이렇게 같은 파라미터 변수를 연산에 쓰거나, b = multiFunc() 처럼 함수를 넣을 수 있다. (물론 반환값이 있는 함수어야 함)
    console.log(a + b);
}


============================================================================================================

2. es5지만 유용한 arguments >> 하지만 es6에서는 더 편리한 rest가 나온다...

JS에서 Parameter, Argument를 가끔 구분해서 부를때

function func(a, b, c) { << 얘를 Parameter
    console.log(a, b, c); << 얘를 Argument
}

이때, JS에서 함수 Parameter를 한번에 싸잡아 다룰 필요가 있는 상황에서 사용하는 keyword : arguments : 파라미터 정보를 담은 배열 (정확히 배열은 아님)

function func(a, b, c) {
    console.log(arguments); >> 정보 확인
}

arguments[index]로 파라미터 값을 각 꺼내올 수 있음

function func(a, b, c, d, e, f) {
    for(let i=0; i<arguments.length; i++) {
        console.log(arguments[i]);
    } // 이렇게 하거나

    // arguments.forEach(e => console.log(e)); >> arguments는 정확히는 그냥 Array가 아니기에 forEach같은 함수 사용이 안된다.
}


============================================================================================================


3. es6 : Rest Parameter

기존 arguments 단점 극복이 됨 + 매우 동적으로 파라미터 세팅이 됨

... 의 의미 : 1. spread operator, 2. rest parameter

function func(...resttest) { 
    console.log(resttest);
}

func(1,2,3,4,5,6,7);을 하면 해당 파라미터들이 arguments와 같은 유사 Array가 아니라 1)진짜 Array로 묶인다. >> 즉 forEach와 같은 배열관련 함수들을 사용이 가능하다!!

즉 함수 정의 시 ...rest 로 파라미터를 정의하면 이후 2)동적으로 들어온 파라미터들에 대해 Array로 감싸 사용이 가능하다. >> 다시보니 JS자체가 애초에 동적으로 받을 수 있어서 arguments도 사용은 가능 대신 rest가 더 효율적
동시에
arguments는 일단 들어온 파라미터를 전부 담지만, rest는 함수 정의시 세팅된 영역에 대해서만 담기 때문에

function func(a,b,...rest) {
    console.log(a);
    console.log(b);
    console.log(rest);
}
이렇게 필요에 따라 3)간편히 영역 지정이 되는 효율성도 확보된다.


대신 rest parameter의 중요한 주의점 (말그대로 rest, 나머지 의미임 무슨 representational state transfer 이런거 아님)
>> 뒤의 모든 파라미터를 의미하므로 rest parameter의 위치는 최후미에 둬야함 (다른 파라미터를 뒤에 더 넣음 안됨) (...rest, a, b) 안됨
>> 마찬가지로 rest파라미터를 여러개 둘 수 없음(...rest1, ...rest2) 안됨

===============================================================================================================================

Exercise Tip)
1)
function sumFunc(a, b = 2 * 5) {
    console.log(a + b);
}

func(1, undefined); >> undefined된 부분은 default값이 뜸 >> 지정 안된 영역은 undefined 취급됨

2)
function makeArray1(...rest) {
    return rest;
}
function makeArray2() {
    let arr = [];
    arr.length = arguments.length;
    for (let i = 0; i < arguments.length; i++) {
        arr[i] = arguments[i];
    }
    return arr;
}
var newArr1 = makeArray1(1, 2, 3, 4, 5);
console.log(newArr1);

var newArr2 = makeArray2(1, 2, 3, 4, 5);
console.log(newArr2);

해보니 애초에 javascript가 파라미터를 동적으로 받는게 되므로 arguments도 처리가 됨 대신 rest가 더 효율적일뿐


3) JS에서도 Math. 란 패키지에 sqrt나 max와 같은 JAVA와 비슷한 내장함수가 들어가 있다!!


★☆★ 저번 spread operator할때 오브젝트 내에 변수로 특정 key에 변수를 지정할 때 {[key]: value}을 이야기했지만

추가적으로 할당 이후에도 변수로 key를 지정할 수 있음
기존 object.key = value; 였다면 key를 변수로 사용할 때는 Array처럼 object[key] = value;을 하면 됨. 물론 object['key'] = value;도 됨