1. Destructuring(패턴 매칭)

const arr = [2,3,4,5];

const a = arr[0]; const b = arr[1];

const [a, b, c = 10] = [2, 3]; // c처럼 default 할당 값을 지정할 수도 있다.
const [a,b,c] = arr; // 지정이 안된 부분은 undefined가 되고 지정한 부분까지 변수에

===========

const obj = {
    name: 'kim',
    age: 19,
    greeting: function() {

    }
}

const name = obj.name;

const {name, age, greeting} = obj;

const {name = 'chin', age : 나이 = 31, greeting: sayHi} = obj; // 마찬가지로 default 지정가능 + 해당 키에 대한 변수명을 :을 이용하여 변경할 수 있따.


이런식으로 객체 요소를 변수로 저장할 때 좀 더 직관적이고 간편하게 만드는 방법
Array는 순서를 맞춘다면 Object는 key 이름을 맞춘다.
>> 그럴만도 한게 Array는 index로 메모리 주소를 계산한다면 Object는 아마 해시테이블을 이용해 key로 찾아가니까 순서랑 상관이 없지


>> 라이브러리에서 함수 등을 가져올 때도 잘 써먹는다.

===========

역으로 변수의 값을 object에 넣을 경우

const name = 'kim';
const age = 30;

const obj = {name: name, age: age}; 로 사용하던 것을 축약해

>> const obj = {name, age};로 변경이 가능하다.


============

함수의 파라미터를 만들때도 사용이 가능하다

const obj = {name: 'chin', age: 29};

function func({name, age}) {
    console.log(})
}

func(obj)

이렇게 파라미터 객체를 변수로 Destructuring이 가능하다. (같은 방법으로 Array도 가능)


=============

const obj = {
    body: {
        height: 180,
        weight: 65
    },
    size: ['L', 28]
}

const {
    body: {
        height, weight
    },
    size: [shirts, pants]
} = obj;

이런식으로 형태, 구조만 맞춰주면 다양하게 쓰일 수 있다.


=========================================================================================================================
=========================================================================================================================

2. import, export >> 코드가 길어지는 것을 방지하기 위해 파일을 분할하기 위함

기존 JS 파일 첨부

>> .js 파일 후 <script>의 src 어트리뷰트로 첨부

es6부터는 Java와 같은 일반적인 프로그래밍+직관적인 방법으로 첨부가 가능

html에서 기준

script 태그의 type 어트리뷰트를 module로 지정,
import ~ from '경로'로 .js 파일에서 import가 가능

근데 import 사용시는 src로 전체를 가져오는 것이 아니기에 import ~에 변수 등을 지정하는게 필요하고
export를 통해 무엇(변수, 함수, 클래스 등)을 import하게 할지 지정이 가능하다.

옛날에는 module.export.변수 = 할당값 & const 변수 = require('경로'); 로 가져옴
근데 IE 호환 문제로 React 같은 프레임워크가 아니면 src로 모듈 전체를 가져온다.

export 시는

1) export default 변수명; 을 통해 어떤 변수를 export 할 지 설정이 가능하고
   default로 보낼 것이 하나의 객체이기에 import측에서는 받아오는 객체의 변수명을 임의로 지정할 수 있다.

    const ex1 = 10;
    const ex2 = 20;

    const obj = {ex1, ex2};  // default로 보낼 때 보내야 할 것이 여러개인 경우 이런식으로 object나 array로 감싸서 처리하면 된다.

    export default obj;


    import 임의 from '경로';

    임의.ex1;
   
   
2) 만약 하나 이상의 변수를 지정해서 export 하고 싶다면

    const ex1 = 10;
    const ex2 = 20;
    
    export const ex3 = 30; // 변수에 바로 export를 붙여 내보낼 수 있다,
    
    export {ex1, ex2}; // 하나만 있어도 중괄호 필요
    
    ===============
    
    import {ex1, ex2, ex3} from '경로'
    
    console.log(ex1); // 이런식으로 가져온다.
    

3) 참고로 export와 export default는 동시사용이 가능하다 (당근 import 방법이 애초에 다름으로 구분지어 사용하면 됨)

    const ex1 = 10;
    const ex2 = 20;
    export const ex3 = 30;
    
    const exObj = {ex1, ex2, ex3};
    
    export {ex1, ex2};
    export default exObj;
    
    ==============
    
    import {ex1, ex3} from ~
    import 임의 from ~ //여기에 exObj
    
    혹은
    
    import 임의, {ex1, ex2, ex3} from ~;
    
    주의할건 import문을 한줄로 축약시키는 경우 default로 가져오는 임의 변수를 먼저 써야한다.
    
    
4) 변수명이 지정된 export {}인 경우 import시 as구문을 통해 변수명을 바꿔 사용할 수 있다.

    import {ex1 as work1} from ~;
    
    console.log(work1);
    
    
5) *을 활용하여 전체를 import 할 수 있다

    import 임의,  as * obj from ~;
    
    console.log(obj.ex1);
    console.log(임의);
    
    이렇게 오브젝트 데이터로 한번에 가져오는 객체로 처리 가능하고 보통 as를 사용해 해당 객체를 사용하기 위한 변수를 지정한다.
    +
    그리고 default로 지정한 데이터는 위 *의 방법을 쓰지 못하기에 사용하려면 저렇게 같이 import를 해야함



=========================================================================================================================
=========================================================================================================================

3. 웹브라우저(JS 컴파일하는게 웹브라우저니까) 동작원리 >> Heap, Stack, Queue

일반적인 프로그래밍 언어들은 위에서 부터 읽어나감
print(1 + 1);
time.sleep(1);
print(2 + 2);  // Python인데 위에서부터 순차실행됨

console.log(1+1);
setTimeout(function(){},1000); // 비동기 함수이므로 걍 바로 아래것이 실행됨
console.log(2+2);

console.log(1+1);
setTimeout(function() {
    console.log(2 + 2);
    console.log(3 + 3);
}, 1000); 이렇게 해야 의도한 대로 된다.


웹브라우저 JS 해석 원리, 단계

Stack에 함수를 넣어 실행 관리하고
Heap에 함수에서 사용되는 변수들 관리

Stack(후입선출)은 한개밖에 없기에 함수코드가 한개씩 실행(Single Threaded Langauge, 병렬처리가 안됨)
하지만 ajax, setTimeout, eventListener 등 시간이 걸리는 비동기 처리함수들은 잠시 제끼게 정해짐 >> 자바는 원래 stack으로 동기적 처리 but 이런 얘들만 비동기 처리가 가능

그리고 이 비동기 코드 중 대기가 끝난 함수들은 콜백Queue(이벤트 Queue 선입선출)에 순서대로 정리하여 Stack으로 올려보냄 (Stack이 비었을 때만)

따라서 이런 과정을 거치기 때문에

console.log(1+1);
setTimeout(function(){
    console.log(2+2);
}, 0);
console.log(3+3); 을 하여 setTimeout의 대기초를 0으로 맞춰도 일단 비동기처리함수는 제끼고 콜백Queue로 보낸뒤 다시 stack으로 넘어오기 때문에 
2 > 6 > 4의 순으로 콘솔에 찍힌다.


빈복문 작업이 복잡하거나 반복이 길어질 때 작업이 버벅이는 이유 (애초에 이런 복잡한 연산은 JS에 시키면 안됨)
>> stack이 하나이기에 이 반복문을 처리하는 동안 Queue에 쌓인 이벤트, Ajax들이 Stack에 올려보내지도, 처리되지 않고 쌓이게 됨 >> 브라우저 freezing 흔한 원인 중 하나


>> Stack과 Queue가 바쁘게 하는 코드를 짜면 안된다.


=========================================================================================================================
=========================================================================================================================

4. 동기 / 비동기 처리 + 콜백함수

위에서처럼 JS 자체는 기본적으로 한줄씩 실행되는 동기(sync) 방식이다.
뭔가 실제로 병렬처리가 되는게 절대 아님.

하지만 위에서도 언급한 setTimeout, setInterval, eventListener, ajax와 같이 async 방식의 함수들이 있다.
일반적인 언어에서는 좀 많이 색다른 케이스,
왜냐하면 멀티스레드와 같은 환경이 아닌 싱글스레드의 경우 위와 같은 작업이 다 처리될 때까지 다른 작업이 안 들어가고 동기적으로 처리되기 때문이다.

하지만 JS에서는 위와 같은 비동기 함수들이 따로 빼서 대기시킨 후 다시 스택으로 옮겨오는 방식으로 처리하기 때문에
실제 싱글스레드 작업이지만 병렬처리가 되는 것처럼 보이게 되는 현상을 가져올 수 있다.


위에서는 설명이 부족했는데 비동기함수들은 Queue대기열로 가기 전 Ajax요청수신이나 이벤트 발생, 시간완료 등의 처리가 되는 것을 기다리기 위해
웹브라우저는 Web API라는 공간으로 보내진다.

JS는 웹 페이지 랜더링에도 관여하기에 이런 비동기성이 필요로 한다.

이런 비동기 함수들의 특성으로 뭔가 쉽게 병렬스러운 작업이 되지만
실제는 싱글스레드 환경이기에 기본 동기 함수들의 복잡한 작업처리를 시키면 멀티스레드를 지원하는 다른 프로그래밍언어와 달리 굉장한 작업 다운을 경험하게 된다.


>> 만약 비동기 함수가 끼었는데 순차 실행을 시키고 싶다면? 비동기 함수의 콜백함수 내에 순차적으로 넣으면 됨
>> 이렇게 JS의 콜백함수는 함수 내에 함수를 넣음으로서 함수의 순차실행을 의도하게 하는 용으로도 쓰인다.

그럼 callback은 왜 이런식으로 실행될까?

function first() {
    setTimeout(()->{console.log(1)}, 1000);
}
function second() {
    console.log(2);
}

first();
second();
을 하면 first()가 먼저 실행될까? 실행은 되지만 만약 first함수 코드 내에 비동기함수가 있다면 그부분은 나중에 실행된다.
따라서 위에서는 2가 먼저 출력된다.

이런 상황에서 뭔가 1,2를 순서출력하고 싶다면
first 내부 setTimeout에 second() 함수를 실행시켜야 하고 이를 좀 더 재사용성을 높게 하려면 함수를 파라미터로 받아와 처리하면 된다.
(JS는 람다식 같은거 없이 간편히 함수도 파라미터로 받아 올 수 있다)

function first(sec) {
    setTimeout(()=>{ // 물론 콜백함수가 비동기 등의 순서를 지정해주지 않기에 단지 이렇게 순서를 좀 더 확립하기 위한 방법이다.
        console.log(1);
        sec();
    }, 1000);
}

function second(third) {
    console.log(2);
    third();
}

first(second);
// 물론 아래처럼 람다식처럼 짤 수도 있다.
fisrt(()=>{
    console.log(2);
});

아님 이런것도 있고
first(()=>{
    second(()=>{
        console.log('third');
    });
});

이런식으로 내장함수의 callback을 사용하는 것 뿐 아니라,
디자인패턴적으로 콜백함수를 사용할 수 있다. 물론 어디까지나 활용의 범위이며 실제로 어떤 처리순서를 보장해주는 것이 아니다. 이 부분은 개발자가 알아서 짜는 것

뭐 Java같은 것만 해도
메서드.메서드.메서드 이렇게 하면 우측부터 스택에서 반환값을 받아 순차 실행되는데
이런것들이 잘 안먹힐 때가 있는 JS에서 고육지책으로 하는것도 콜백이긴 하다. 그래서 좀 더 직관적으로 사용하기 위한 것이 Promise